////////////////////////////////////////////////////////////////////////// Black Box UVA - 501

////////////////////// primera version
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

void processDataSet() {
    int m, n, u;
    std::cin >> m >> n;
    std::vector<int> nums(m);
    std::vector<int> set(m + 1); // +1 for not overlapping the search
    int size = 1, it = 1;
    bool first = true;

    for (int i = 0; i < m; i++) {
        std::cin >> nums[i];
    }

    set[0] = INT_MIN;
    set[1] = nums[0];

    for (int i = 0; i < n; i++) {
        std::cin >> u;
        while (u > size) {
            size++;
            set[size] = nums[size - 1];
            int j = size;
            while (set[j] < set[j - 1]) {
                std::swap(set[j], set[j - 1]);
                j--;
            }
        }
        if (first) {
            first = false;
        } else {
            it++;
        }
        std::cout << set[it] << "\n";
    }
}

int main() {
    int t;
    std::cin >> t;

    while (t--) {
        processDataSet();
        if (t) {
            std::cout << "\n";
        }
    }

    return 0;
}

////////////////////// segunda version
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

int main() {
    int t, m, n, u;
    std::cin >> t;
    while (t--) {
        std::cin >> m >> n;
        std::vector<int> nums(m);
        std::vector<int> set(m + 1); // +1 for not overlapse the search
        int size = 1, it = 1;
        bool first = true;
        for (int i = 0; i < m; i++) {
            std::cin >> nums[i];
        }
        set[0] = INT_MIN;
        set[1] = nums[0];
        for (int i = 0; i < n; i++) {
            std::cin >> u;
            while (u > size) {
                size++;
                set[size] = nums[size - 1];
                int j = size;
                while (set[j] < set[j - 1]) {
                    std::swap(set[j], set[j - 1]);
                    j--;
                }
            }
            if (first) {
                first = false;
            } else {
                it++;
            }
            std::cout << set[it] << "\n";
        }
        if (t) {
            std::cout << "\n";
        }
    }
    return 0;
}

////////////////////////////////////////////////////////////////////////// Andy's Second Dictionary UVA - 11062

////////////////////// primera version
#include <iostream>
#include <map>
#include <string>
#include <cctype>

void processCharacter(char input, std::string& word, std::map<std::string, int>& dict) {
    if (std::isupper(input)) {
        input = std::tolower(input);
    }
    if (std::islower(input)) {
        word += input;
    } else if (input != '-') {
        if (!word.empty()) {
            dict[word] = 0;
        }
        word = "";
    } else {
        std::cin.get(input);
        if (input != '\n') {
            if (std::isupper(input)) {
                input = std::tolower(input);
            }
            word += '-';
            word += input;
        }
    }
}

void printDictionary(const std::map<std::string, int>& dict) {
    for (const auto& it : dict) {
        std::cout << it.first << std::endl;
    }
}

int main() {
    std::map<std::string, int> dict;
    std::string word = "";
    char input;

    while (std::cin.get(input)) {
        processCharacter(input, word, dict);
    }

    printDictionary(dict);

    return 0;
}

////////////////////// segunda version
#include <iostream>
#include <map>
#include <string>
#include <cctype>

int main() {
    std::map<std::string, int> dict;
    std::string word = "";
    char input;

    while (std::cin.get(input)) {
        // Convierte el carácter a minúscula
        if (std::isupper(input)) {
            input = std::tolower(input);
        }
        // Concatena caracteres para formar palabras
        if (std::islower(input)) {
            word += input;
        }
            // Inserta palabra si termina
        else if (input != '-') {
            if (!word.empty()) {
                dict[word] = 0;
            }
            word = "";
        } else {
            std::cin.get(input);
            // Caso de palabra con guión
            if (input != '\n') {
                if (std::isupper(input)) {
                    input = std::tolower(input);
                }
                word += '-';
                word += input;
            }
        }
    }

    // Imprime el diccionario
    for (const auto& it : dict) {
        std::cout << it.first << std::endl;
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////// My Dear Neighbours UVA - 10928
#include <bits/stdc++.h>
using namespace std;

vector<int> findMinNeighborCount(const vector<vector<int>>& neighbors) {
    int n = neighbors.size();
    vector<int> g(n);
    int mn = INT_MAX;

    for (int i = 0; i < n; i++) {
        for (int neighbor : neighbors[i]) {
            g[i]++;
        }
        mn = min(mn, g[i]);
    }

    vector<int> ans;
    for (int i = 0; i < n; i++) {
        if (g[i] == mn) {
            ans.push_back(i + 1);  // Indices are 1-based
        }
    }

    return ans;
}

void solveTestCase() {
    int n;
    cin >> n;
    cin.ignore();

    vector<vector<int>> neighbors(n);
    for (int i = 0; i < n; i++) {
        string s;
        getline(cin, s);
        stringstream str(s);
        int x;
        while (str >> x) {
            neighbors[i].push_back(x);
        }
    }

    vector<int> result = findMinNeighborCount(neighbors);

    for (int i = 0; i < result.size(); i++) {
        cout << result[i];
        if (i + 1 < result.size()) {
            cout << " ";
        }
    }
    cout << endl;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int t;
    cin >> t;
    while (t--) {
        solveTestCase();
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////// Network Connections UVA - 793
/////////////////////////////// primera version
#include <bits/stdc++.h>
using namespace std;

vector<int> parent;

int find(int x) {
    if (parent[x] == x) {
        return x;
    } else {
        parent[x] = find(parent[x]);
        return parent[x];
    }
}

void union_set(int x, int y) {
    parent[find(x)] = find(y);
}

int main() {
    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
    int t; cin >> t;
    while(t--){
        int n; cin >> n;
        parent.resize(n+1);
        iota(parent.begin(), parent.end(), 0);
        string s;
        getline(cin, s);
        int successful = 0, unsuccessful = 0;
        while(getline(cin, s), !s.empty()){
            stringstream str(s);
            char type; int i, j;
            str >> type >> i >> j;
            if(type == 'c'){
                union_set(i, j);
            } else if(type == 'q'){
                if(find(i) == find(j)){
                    successful++;
                } else {
                    unsuccessful++;
                }
            }
        }
        cout << successful << "," << unsuccessful << endl;
        if(t) cout << endl;
    }
    return 0;
}

/////////////////////////////// segunda version
#include <bits/stdc++.h>
using namespace std;

vector<int> parent;

int find(int x) {
    return parent[x] == x ? x : parent[x] = find(parent[x]);
}

void union_set(int x, int y) {
    parent[find(x)] = find(y);
}

int main() {
    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);
    int t; cin >> t;
    while(t--){
        int n; cin >> n;
        parent.resize(n+1);
        iota(parent.begin(), parent.end(), 0);
        string s;
        getline(cin, s);
        int successful = 0, unsuccessful = 0;
        while(getline(cin, s), !s.empty()){
            stringstream str(s);
            char type; int i, j;
            str >> type >> i >> j;
            if(type == 'c'){
                union_set(i, j);
            } else if(type == 'q'){
                successful += (find(i) == find(j));
                unsuccessful += (find(i) != find(j));
            }
        }
        cout << successful << "," << unsuccessful << "\n";
        if(t) cout << "\n";
    }
    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////// Nature UVA - 10685
/////////////////////////////// primera version
#include <bits/stdc++.h>
using namespace std;

#define IOS ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define ll long long
int N = 1e5;

int dfs(int node, unordered_map<int, vector<int>> &vec, vector<bool> &vis, int count){
    vis.at(node) = 1;
    count++;
    for(auto now : vec.at(node)){
        if(vis.at(now) == 0){
            count = dfs(now, vec, vis, count);
        }
    }
    return count;
}

int main(){
    int reading = 0, paper = 0;
    reading = 1;
    paper = 1;
    if(!reading and !paper) return 0;
    IOS;
    int n, m;
    while(cin >> n >> m and n or m){
        unordered_map<int, vector<int>> vec;
        unordered_map<string, int> animals;
        for (int i = 0; i < n; ++i) {
            string a;
            cin >> a;
            animals[a] = i;
            vec[i] = vector<int>();
        }
        for (int i = 0; i < m; ++i) {
            string a, b;
            cin >> a >> b;
            vec.at(animals[a]).push_back(animals[b]);
            vec.at(animals[b]).push_back(animals[a]);
        }
        vector<bool> vis(n, 0);
        int count = 0;
        for (int i = 0; i < n; ++i) {
            count = max(count, dfs(i, vec, vis, 0));
        }
        cout << count << endl;
    }
    return 0;
}

/////////////////////////////// segunda version
#include <bits/stdc++.h>
using namespace std;

#define IOS ios_base::sync_with_stdio(false);cin.tie(NULL);cout.tie(NULL);
#define ll long long

class AlimentaryChain {
public:
    AlimentaryChain(int n, int m) : n(n), m(m), vec(n), animals(n), vis(n, false) {}

    void addCreature(const string& creature, int index) {
        animals[creature] = index;
    }

    void addRelation(const string& creatureA, const string& creatureB) {
        vec[animals[creatureA]].push_back(animals[creatureB]);
        vec[animals[creatureB]].push_back(animals[creatureA]);
    }

    int findLongestChain() {
        int maxChainLength = 0;
        for (int i = 0; i < n; ++i) {
            if (!vis[i]) {
                maxChainLength = max(maxChainLength, dfs(i, 0));
            }
        }
        return maxChainLength;
    }

private:
    int n, m;
    vector<vector<int>> vec;
    unordered_map<string, int> animals;
    vector<bool> vis;

    int dfs(int node, int count) {
        vis[node] = true;
        count++;
        for (const int& neighbor : vec[node]) {
            if (!vis[neighbor]) {
                count = dfs(neighbor, count);
            }
        }
        return count;
    }
};

int main(){
    int reading = 0, paper = 0;
    reading = 1;
    paper = 1;
    if (!reading && !paper) return 0;
    IOS;
    int n, m;
    while (cin >> n >> m && (n || m)) {
        AlimentaryChain chain(n, m);
        for (int i = 0; i < n; ++i) {
            string a;
            cin >> a;
            chain.addCreature(a, i);
        }
        for (int i = 0; i < m; ++i) {
            string a, b;
            cin >> a >> b;
            chain.addRelation(a, b);
        }
        int longestChain = chain.findLongestChain();
        cout << longestChain << endl;
    }
    return 0;
}

////////////////////////////////////////////////////////////////////////// War UVA - 10158
#include <bits/stdc++.h>
using namespace std;

int find(vector<int> &p, int x) {
    return p[x] == x ? x : p[x] = find(p, p[x]);
}

void unionSets(vector<int> &p, int a, int b) {
    int rootA = find(p, a);
    int rootB = find(p, b);
    if (rootA != rootB) {
        p[rootA] = rootB;
    }
}

bool areInSameSet(vector<int> &p, int a, int b) {
    return find(p, a) == find(p, b);
}

int main() {
    int n;
    cin >> n;

    vector<int> p(2 * n);
    for (int i = 0; i < 2 * n; i++) {
        p[i] = i;
    }

    int op, x, y, a1, a2, b1, b2;
    while (cin >> op >> x >> y) {
        if (op == 0) return 0;

        a1 = find(p, x);
        a2 = find(p, x + n);
        b1 = find(p, y);
        b2 = find(p, y + n);

        if (op == 1) {
            if (a1 == b2 || b1 == a2) {
                cout << -1 << endl;
            } else {
                unionSets(p, a1, b1);
                unionSets(p, a2, b2);
            }
        } else if (op == 2) {
            if (a1 == b1) {
                cout << -1 << endl;
            } else {
                unionSets(p, a2, b1);
                unionSets(p, b2, a1);
            }
        } else if (op == 3) {
            cout << areInSameSet(p, a1, b1) << endl;
        } else if (op == 4) {
            cout << areInSameSet(p, a1, b2) << endl;
        }
    }
}

///////////////////////////////////////////////////////////////////////////////////////// The Suspects UVA - 1197
/////////////////////////////// primera version
#include <iostream>
#include <vector>

using namespace std;

const int MAX_N = 30005;
vector<int> adj[MAX_N];
bool isSuspect[MAX_N];

void dfs(int u) {
    isSuspect[u] = true;
    for (int v : adj[u]) {
        if (!isSuspect[v]) {
            dfs(v);
        }
    }
}

int main() {
    int n, m;
    while (cin >> n >> m && n > 0) {
        for (int i = 0; i < n; i++) {
            adj[i].clear();
            isSuspect[i] = false;
        }

        while (m--) {
            int k;
            cin >> k;
            vector<int> group(k);
            for (int i = 0; i < k; i++) {
                cin >> group[i];
            }
            for (int i = 1; i < k; i++) {
                adj[group[0]].push_back(group[i]);
                adj[group[i]].push_back(group[0]);
            }
        }

        dfs(0);

        int suspectCount = 0;
        for (int i = 0; i < n; i++) {
            if (isSuspect[i]) {
                suspectCount++;
            }
        }

        cout << suspectCount << endl;
    }

    return 0;
}

/////////////////////////////// segunda version
#include <iostream>
#include <map>

using namespace std;

map<long long, long long> parent;
map<long long, long long> siz;

long long findset(long long v) {
    if (v == parent[v])
        return v;
    return parent[v] = findset(parent[v]);
}

void unionn(long long a, long long b) {
    a = findset(a);
    b = findset(b);
    if (a == b)
        return;
    else {
        if (siz[a] < siz[b])
            swap(a, b);
        parent[b] = a;
        siz[a] += siz[b];
    }
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cout.tie(0);
    long long a, b;
    long long n, m, i, j, k = 1, l;

    while (cin >> n >> m && (n + m) > 0) {
        for (i = 0; i < n + 4; i++) {
            parent[i] = i;
            siz[i] = 1;
        }
        for (i = 0; i < m; i++) {
            cin >> k >> l;
            k--;
            while (k--) {
                cin >> a;
                unionn(l, a);
            }
        }
        cout << siz[findset(0)] << endl;
        parent.clear();
        siz.clear();
    }
}

////////////////////////////////////////////////////////////////////////// Minimal coverage UVA - 10020
////////////////////// primera version
#include <bits/stdc++.h>
using namespace std;

void solve(){
    int m; cin >> m;
    vector<pair<int, int>> a;
    int l, r;
    while(cin >> l >> r){
        if(l == 0 and  r == 0) break;
        a.emplace_back(l, r);
    }
    int n = a.size();
    sort(a.begin(), a.end());
    vector<pair<int,int>> ans;
    pair<int, int> best = {-1,-1};
    int goal = 0, at = 0;
    while(goal < m){
        while(at < n and a[at].first <= goal){
            if(a[at].second > best.second){
                best = a[at];
            }
            at++;
        }
        if(best.second > goal){
            ans.push_back(best);
            goal = best.second;
        }
        else{
            cout << 0 << endl;
            return;
        }
    }
    cout << ans.size() << endl;
    for(auto [x, y] : ans) cout << x << " " << y << endl;
}

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int t; cin >> t;
    for(int cas = 1; cas <= t; cas++){
        if(cas > 1) cout << endl;
        solve();
    }
}

////////////////////// segunda version
#include <bits/stdc++.h>
using namespace std;

vector<pair<int, int>> read_intervals(){
    vector<pair<int, int>> a;
    int l, r;
    while(cin >> l >> r){
        if(l == 0 and  r == 0) break;
        a.emplace_back(l, r);
    }
    return a;
}

pair<int, int> find_best_interval(vector<pair<int, int>>& a, int& at, int goal){
    pair<int, int> best = {-1,-1};
    int n = a.size();
    while(at < n and a[at].first <= goal){
        if(a[at].second > best.second){
            best = a[at];
        }
        at++;
    }
    return best;
}

void solve(){
    int m; cin >> m;
    vector<pair<int, int>> a = read_intervals();
    sort(a.begin(), a.end());
    vector<pair<int,int>> ans;
    int goal = 0, at = 0;
    while(goal < m){
        pair<int, int> best = find_best_interval(a, at, goal);
        if(best.second > goal){
            ans.push_back(best);
            goal = best.second;
        }
        else{
            cout << 0 << endl;
            return;
        }
    }
    cout << ans.size() << endl;
    for(auto [x, y] : ans) cout << x << " " << y << endl;
}

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    int t; cin >> t;
    for(int cas = 1; cas <= t; cas++){
        if(cas > 1) cout << endl;
        solve();
    }
}

///////////////////////////////////////////////////////////////////////////////////////// Corporative Network UVA - 1329
/////////////////////////////// primera version
#include<bits/stdc++.h>
using namespace std;

const int MAXN = 20005;
int parent[MAXN], dist[MAXN];

int find(int x) {
    if(parent[x] == x) return x;
    int root = find(parent[x]);
    dist[x] += dist[parent[x]];
    return parent[x] = root;
}

void union_(int x, int y) {
    parent[x] = y;
    dist[x] = abs(x - y) % 1000;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int T;
    cin >> T;
    while(T--) {
        int N;
        cin >> N;
        for(int i = 1; i <= N; i++) {
            parent[i] = i;
            dist[i] = 0;
        }
        char op;
        while(cin >> op && op != 'O') {
            if(op == 'E') {
                int x;
                cin >> x;
                find(x);
                cout << dist[x] << "\n";
            } else if(op == 'I') {
                int x, y;
                cin >> x >> y;
                union_(x, y);
            }
        }
    }

    return 0;
}

/////////////////////////////// segunda version
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 20005;
int parent[MAXN], dist[MAXN];

int find(int x) {
    if (parent[x] == x) return x;
    int root = find(parent[x]);
    dist[x] += dist[parent[x]];
    return parent[x] = root;
}

void union_(int x, int y) {
    parent[x] = y;
    dist[x] = abs(x - y) % 1000;
}

void processQueries(int N) {
    for (int i = 1; i <= N; i++) {
        parent[i] = i;
        dist[i] = 0;
    }

    char op;
    while (cin >> op && op != 'O') {
        if (op == 'E') {
            int x;
            cin >> x;
            find(x);
            cout << dist[x] << "\n";
        } else if (op == 'I') {
            int x, y;
            cin >> x >> y;
            union_(x, y);
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    int T;
    cin >> T;
    while (T--) {
        int N;
        cin >> N;
        processQueries(N);
    }

    return 0;
}

////////////////////////////////////////////////////////////////////////// Radar Installation UVA - 1193
////////////////////// primera version
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

const double eps = 1e-8;
const int N = 1005;
int n, t , ans;
double R;
bool yes;

struct point{
    double l, r;
    friend bool operator < (const point &a, const point &b){
        return a.r < b.r;
    }
};

vector<point> p(N);

int main(){
    while(1){
        t++;
        cin >> n >> R;
        if(n == 0 && R == 0) break;
        yes = 1;
        double x,y,k;
        for(int i = 1; i <= n; i++){
            cin >> x >> y;
            if(y > R+eps) yes = 0;
            else {
                k = sqrt(R * R - y * y);
                p[i].l = x - k;
                p[i].r = x + k;
            }
        }
        if(!yes){
            cout << "Case " << t << ": -1\n";
            continue;
        }
        sort(p.begin()+1, p.begin()+n+1);
        ans = 0;
        double last = -1e9;
        for(int i = 1; i <= n; i++){
            if(p[i].l > last) ans++,last = p[i].r;
        }
        cout << "Case " << t << ": " << ans << "\n";
    }
}

////////////////////// segunda version
#include <bits/stdc++.h>
using namespace std;

const double eps = 1e-8;
const int N = 1005;
int n, t , ans;
double R;
bool yes;

struct point{
    double l, r;
    friend bool operator < (const point &a, const point &b){
        return a.r < b.r;
    }
};

vector<point> p(N);

void read_points() {
    double x,y,k;
    for(int i = 1; i <= n; i++){
        cin >> x >> y;
        if(y > R+eps) yes = 0;
        else {
            k = sqrt(R * R - y * y);
            p[i].l = x - k;
            p[i].r = x + k;
        }
    }
}

void solve() {
    sort(p.begin()+1, p.begin()+n+1);
    ans = 0;
    double last = -1e9;
    for(int i = 1; i <= n; i++){
        if(p[i].l > last) ans++,last = p[i].r;
    }
}

int main(){
    while(1){
        t++;
        cin >> n >> R;
        if(n == 0 && R == 0) break;
        yes = 1;
        read_points();
        if(!yes){
            cout << "Case " << t << ": -1\n";
            continue;
        }
        solve();
        cout << "Case " << t << ": " << ans << "\n";
    }
}

////////////////////////////////////////////////////////////////////////// Shopaholic UVA - 11369
#include <bits/stdc++.h>
using namespace std;

int best_offer(vector<int> p){
    sort(p.begin(), p.end());
    int res = 0;
    for(int i = p.size()-3; i >= 0; i = i - 3){
        res = res + p[i];
    }
    return res;
}

int main(){
    int c;
    cin >> c;
    int n;
    for(int i = 0; i < c; i++){
        cin >> n;
        vector <int > v(n);
        for(int j = 0; j < n; j++){
            cin >> v[j];
        }
        cout << best_offer(v) << endl;
    }
}

///////////////////////////////////////////////////////////////////////////////////////// Commando War UVA - 11729
/////////////////////////////// primera version
#include <bits/stdc++.h>
using namespace std;

struct node{
    int a, b;
};

bool cmp(const node &x, const node &y){
    return max(x.a + x.b, x.a + y.a + y.b) < max(y.a + y.b, x.a + x.b + y.a);
}

int main(){
    int t = 1;
    int n;

    while(true){
        cin >> n;
        if( n == 0){
            break;
        }
        vector<node> c(n);
        for(auto &v : c){
            cin >> v.a >> v.b;
        }
        sort(c.begin(), c.end(), cmp);

        int ans = 0;
        int sum = 0;
        for(int i = 0; i < n; i++){
            sum += c[i].a;
            ans = max(ans, sum + c[i].b);
        }
        cout << "Case " << t << ": " << ans << endl;
        t++;
    }
}

/////////////////////////////// segunda version
#include <bits/stdc++.h>
using namespace std;

struct node{
    int a, b;
};

bool cmp(const node &x, const node &y){
    return max(x.a + x.b, x.a + y.a + y.b) < max(y.a + y.b, x.a + x.b + y.a);
}

vector<node> read_nodes(int n){
    vector<node> c(n);
    for(auto &v : c){
        cin >> v.a >> v.b;
    }
    return c;
}

int calculate_ans(vector<node> &c){
    int ans = 0;
    int sum = 0;
    for(int i = 0; i < c.size(); i++){
        sum += c[i].a;
        ans = max(ans, sum + c[i].b);
    }
    return ans;
}

void solve_case(int t){
    int n;
    cin >> n;
    if(n == 0){
        exit(0);
    }

    vector<node> c = read_nodes(n);

    sort(c.begin(), c.end(), cmp);

    int ans = calculate_ans(c);

    cout << "Case " << t << ": " << ans << endl;
}

int main(){
    int t = 1;

    while(true){
        solve_case(t++);
    }
}

///////////////////////////////////////////////////////////////////////////////////////// Boiled Eggs UVA - 11900
/////////////////////////////// primera version
#include <bits/stdc++.h>
using namespace std;

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    int tc;
    cin >> tc;
    int v = 1;
    while(tc--){
        int n, p, q, ans = 0;
        cin >> n >> p >> q;
        map<int, int> values;
        for(int i = 0; i < n; i++){
            cin >> values[i];
            if(p-1 >= 0 and q - values[i] >= 0){
                ans++;
                p--;
                q -= values[i];
            }
        }
        cout << "Case " << v << ": " << ans << endl;
        v++;
    }
}

/////////////////////////////// segunda version
#include <bits/stdc++.h>
using namespace std;

int calculateAns(int n, int p, int q, map<int, int>& values) {
    int ans = 0;
    for(int i = 0; i < n; i++){
        if(p-1 >= 0 and q - values[i] >= 0){
            ans++;
            p--;
            q -= values[i];
        }
    }
    return ans;
}

void processTestCases() {
    int tc;
    cin >> tc;
    int v = 1;
    while(tc--){
        int n, p, q;
        cin >> n >> p >> q;
        map<int, int> values;
        for(int i = 0; i < n; i++){
            cin >> values[i];
        }
        int ans = calculateAns(n, p, q, values);
        cout << "Case " << v << ": " << ans << endl;
        v++;
    }
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    processTestCases();
}

///////////////////////////////////////////////////////////////////////////////////////// Football UVA - 12673
/////////////////////////////// primera version
#include <iostream>
#include <map>
#include <algorithm>

using namespace std;

int main(){
    int n, g;
    while (cin >> n >> g){
        int ans = 0;
        map<int, int> m;
        for(int i = 0; i < n; i++){
            int a, b;
            cin >> a >> b;
            if(a > b) ans += 3;
            else m[b - a]++;
        }
        for(auto &x : m){
            while(x.second-- && x.first <= g){
                g -= x.first;
                ans++;
                if(g > 0){
                    ans += 2;
                    g--;
                }
            }
        }
        cout << ans << endl;
    }
    return 0;
}

/////////////////////////////// segunda version
#include <iostream>
#include <map>
#include <algorithm>

using namespace std;

void processMatches(int &ans, map<int, int> &m, int &g) {
    for(auto &x : m){
        while(x.second-- && x.first <= g){
            g -= x.first;
            ans++;
            if(g > 0){
                ans += 2;
                g--;
            }
        }
    }
}

void readMatches(int &n, int &g, int &ans, map<int, int> &m) {
    for(int i = 0; i < n; i++){
        int a, b;
        cin >> a >> b;
        if(a > b) ans += 3;
        else m[b - a]++;
    }
}

int main(){
    int n, g;
    while (cin >> n >> g){
        int ans = 0;
        map<int, int> m;

        readMatches(n, g, ans, m);
        processMatches(ans, m, g);

        cout << ans << endl;
    }
    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////// Shoemaker's Problem UVA - 10026
/////////////////////////////// primera version
#include <bits/stdc++.h>

struct Node {
    long long x, y, id;
};

bool compareNodes(const Node& a, const Node& b) {
    if (a.x * b.y != a.y * b.x) {
        return a.x * b.y < a.y * b.x;
    } else {
        return a.id < b.id;
    }
}

int main() {
    long long testCases, numNodes;
    std::cin >> testCases;
    while (testCases--) {
        std::cin >> numNodes;
        std::map<long long, Node> nodes;
        for (long long i = 1; i <= numNodes; i++) {
            std::cin >> nodes[i].x >> nodes[i].y;
            nodes[i].id = i;
        }

        // Copiar los elementos del mapa a un vector
        std::vector<Node> nodeVector;
        for (const auto& pair : nodes) {
            nodeVector.push_back(pair.second);
        }

        // Ordenar el vector
        std::sort(nodeVector.begin(), nodeVector.end(), compareNodes);

        for (const Node& node : nodeVector) {
            std::cout << node.id;
            if (&node != &nodeVector.back()) {
                std::cout << " ";
            }
        }

        if (testCases != 0) {
            std::cout << "\n";
        }
        std::cout << "\n";
    }

    return 0;
}

/////////////////////////////// segunda version
#include <bits/stdc++.h>

struct Node {
    long long x, y, id;
};

bool compareNodes(const Node& a, const Node& b) {
    if (a.x * b.y != a.y * b.x) {
        return a.x * b.y < a.y * b.x;
    } else {
        return a.id < b.id;
    }
}

std::map<long long, Node> readNodes(long long numNodes) {
    std::map<long long, Node> nodes;
    for (long long i = 1; i <= numNodes; i++) {
        std::cin >> nodes[i].x >> nodes[i].y;
        nodes[i].id = i;
    }
    return nodes;
}

std::vector<Node> mapToVector(const std::map<long long, Node>& nodes) {
    std::vector<Node> nodeVector;
    for (const auto& pair : nodes) {
        nodeVector.push_back(pair.second);
    }
    return nodeVector;
}

void printNodes(const std::vector<Node>& nodeVector) {
    for (const Node& node : nodeVector) {
        std::cout << node.id;
        if (&node != &nodeVector.back()) {
            std::cout << " ";
        }
    }
}

int main() {
    long long testCases, numNodes;
    std::cin >> testCases;
    while (testCases--) {
        std::cin >> numNodes;

        auto nodes = readNodes(numNodes);

        // Copiar los elementos del mapa a un vector
        auto nodeVector = mapToVector(nodes);

        // Ordenar el vector
        std::sort(nodeVector.begin(), nodeVector.end(), compareNodes);

        printNodes(nodeVector);

        if (testCases != 0) {
            std::cout << "\n";
        }
        std::cout << "\n";
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// primera version
#include <bits/stdc++.h>
using namespace std;

int main(){
    int tc;
    cin >> tc;
    for(int i = 1; i <= tc; i++){
        int n, h, ta, td;
        cin >> n >> h >> ta >> td;
        int height[n];
        long long int minTime = 10000000000;
        for(int j = 0; j < n; j++){
            cin >> height[j];
        }
        sort(height, height + n);
        long long int UnMarked = n, marked = 0, shortest = 0, tallest = n-1;
        minTime = min(minTime, (long long)n*ta);

        while(tallest > shortest){
            long long int time;
            if((height[tallest] + height[shortest]) < h){
                tallest--;
                shortest++;
                UnMarked -= 2;
                marked += 1;
            }
            else if((height[tallest] + height[shortest]) >= h){
                tallest--;
            }
            time = UnMarked * ta + marked * td;
            minTime = min(minTime, time);
        }
        cout << "Case " << i << ": " << minTime << endl;
    }
}

/////////////////////////////// segunda version
#include <iostream>
#include <algorithm>
using namespace std;

long long calculateMinTime(int n, int h, int ta, int td, int* height) {
    sort(height, height + n);
    long long int minTime = (long long)n * ta;
    long long int UnMarked = n, marked = 0, shortest = 0, tallest = n - 1;

    while (tallest > shortest) {
        long long int time;
        if ((height[tallest] + height[shortest]) < h) {
            tallest--;
            shortest++;
            UnMarked -= 2;
            marked += 1;
        } else {
            tallest--;
        }
        time = UnMarked * ta + marked * td;
        minTime = min(minTime, time);
    }

    return minTime;
}

int main() {
    int tc;
    cin >> tc;

    for (int i = 1; i <= tc; i++) {
        int n, h, ta, td;
        cin >> n >> h >> ta >> td;
        int height[n];

        for (int j = 0; j < n; j++) {
            cin >> height[j];
        }

        long long int minTime = calculateMinTime(n, h, ta, td, height);
        cout << "Case " << i << ": " << minTime << endl;
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////// Keep the Customer Satisfied UVA - 1153
/////////////////////////////// primera version
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

const int MAX_SIZE = 1e6 + 10;
std::pair<int,int> pairArray[MAX_SIZE];

int main(){
    int numCases;
    std::cin >> numCases;
    while(numCases--){
        int n;
        std::cin >> n;
        std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
        for(int i = 1; i <= n; i++){
            std::cin >> pairArray[i].second >> pairArray[i].first;
        }
        std::sort(pairArray + 1, pairArray + n + 1);
        std::reverse(pairArray + 1, pairArray + n + 1);
        pairArray[n+1] = std::make_pair(0,0);
        int counter = 0;
        for(int i = 1; i <= n; i++){
            minHeap.push(pairArray[i].second);
            int difference = pairArray[i].first - pairArray[i+1].first;
            while(difference > 0 and !minHeap.empty()){
                int x = minHeap.top();
                minHeap.pop();
                int minVal = std::min(x, difference);
                x -= minVal;
                difference -= minVal;
                if(x == 0) counter++;
                else minHeap.push(x);
            }
        }
        std::cout << counter << "\n";
        if(numCases) std::cout << "\n";
    }
    return 0;
}

/////////////////////////////// segunda version
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

const int MAX_SIZE = 1e6 + 10;
std::pair<int, int> pairArray[MAX_SIZE];

// Función para calcular el número de pares compatibles
int calculateCompatiblePairs(int n) {
    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
    int counter = 0;

    for (int i = 1; i <= n; i++) {
        minHeap.push(pairArray[i].second);
        int difference = pairArray[i].first - pairArray[i + 1].first;

        while (difference > 0 && !minHeap.empty()) {
            int x = minHeap.top();
            minHeap.pop();
            int minVal = std::min(x, difference);
            x -= minVal;
            difference -= minVal;

            if (x == 0) counter++;
            else minHeap.push(x);
        }
    }

    return counter;
}

int main() {
    int numCases;
    std::cin >> numCases;

    while (numCases--) {
        int n;
        std::cin >> n;

        for (int i = 1; i <= n; i++) {
            std::cin >> pairArray[i].second >> pairArray[i].first;
        }

        std::sort(pairArray + 1, pairArray + n + 1);
        std::reverse(pairArray + 1, pairArray + n + 1);
        pairArray[n + 1] = std::make_pair(0, 0);

        int counter = calculateCompatiblePairs(n);

        std::cout << counter << "\n";
        if (numCases) std::cout << "\n";
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////// Add All UVA - 10954
/////////////////////////////// primera version
#include <iostream>
#include <map>

int main(){
    int size, number, first, second, sum, total;
    while(true){
        std::cin >> size;
        if(size == 0) break;
        std::map<int, int> numFrequency;
        for(size_t i = 0; i < size; i++){
            std::cin >> number;
            numFrequency[number]++;
        }
        total = 0;
        while(numFrequency.size() > 1){
            auto it1 = numFrequency.begin();
            first = it1->first;
            it1->second--;
            if(it1->second == 0) numFrequency.erase(it1);

            auto it2 = numFrequency.begin();
            second = it2->first;
            it2->second--;
            if(it2->second == 0) numFrequency.erase(it2);

            sum = first + second;
            total += sum;
            numFrequency[sum]++;
        }
        std::cout << total << std::endl;
    }
    return 0;
}

/////////////////////////////// segunda version
#include <iostream>
#include <map>
using namespace std;

// Función para calcular la suma mínima
int calculateMinimumSum(map<int, int>& numFrequency) {
    int total = 0;

    while (numFrequency.size() > 1) {
        auto it1 = numFrequency.begin();
        int first = it1->first;
        it1->second--;
        if (it1->second == 0) numFrequency.erase(it1);

        auto it2 = numFrequency.begin();
        int second = it2->first;
        it2->second--;
        if (it2->second == 0) numFrequency.erase(it2);

        int sum = first + second;
        total += sum;
        numFrequency[sum]++;
    }

    return total;
}

int main() {
    int size, number;
    while (true) {
        cin >> size;
        if (size == 0) break;

        map<int, int> numFrequency;
        for (size_t i = 0; i < size; i++) {
            cin >> number;
            numFrequency[number]++;
        }

        int total = calculateMinimumSum(numFrequency);
        cout << total << endl;
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////// Orchestral scores UVA - 13177
/////////////////////////////// primera version
#include <iostream>
#include <climits>
using namespace std;

int total, num, arr[100010];

bool isValid(int now){
    int sum = 0;
    for(int i = 0; i < num; i++){
        int temp = arr[i];
        int division = temp/now;
        if(temp % now) division++;
        sum += division;
    }
    return (sum <= total);
}

int main(){
    while(cin >> total >> num){
        int maxVal = INT_MIN;
        for(int i = 0; i < num; i++){
            cin >> arr[i];
            maxVal = max(maxVal, arr[i]);
        }
        int high = maxVal, low = 1, ans = maxVal;
        while(high >= low){
            int mid = (high+low)/2;
            if(isValid(mid)){
                ans = mid;
                high = mid-1;
            }
            else low = mid+1;
        }
        cout << ans << endl;
    }
}

/////////////////////////////// segunda version
#include <iostream>
#include <climits>
#include <map>
using namespace std;

int total, num;
map<int, int> heightFrequency;

bool isValid(int now) {
    int sum = 0;
    for (const auto& entry : heightFrequency) {
        int temp = entry.first;
        int division = temp / now;
        if (temp % now) division++;
        sum += division * entry.second;
    }
    return (sum <= total);
}

int main() {
    while (cin >> total >> num) {
        heightFrequency.clear(); // Limpiar el mapa
        int maxVal = INT_MIN;

        for (int i = 0; i < num; i++) {
            int height;
            cin >> height;
            heightFrequency[height]++;
            maxVal = max(maxVal, height);
        }

        int high = maxVal, low = 1, ans = maxVal;

        while (high >= low) {
            int mid = (high + low) / 2;
            if (isValid(mid)) {
                ans = mid;
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }

        cout << ans << endl;
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////// Maximum Sum (II) UVA - 10656
/////////////////////////////// primera version
#include<bits/stdc++.h>
using namespace std;

void solve(){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    long long int n,i,x,f;
    while(true){
        cin >> n;
        if(n == 0) return;
        f = 0;
        for(i = 1; i <= n; i++){
            cin >> x;
            if(x != 0){
                if(f == 0){
                    f = 1;
                    cout << x;
                }
                else cout << " " << x;
            }
        }
        if(f == 0) cout << 0;
        cout << "\n";
    }
}

int main(){
    solve();
    return 0;
}

/////////////////////////////// segunda version
#include<bits/stdc++.h>
using namespace std;

void solve(){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);
    long long int n,i,x;
    while(true){
        cin >> n;
        if(n == 0) return;
        vector<long long int> dp;
        for(i = 1; i <= n; i++){
            cin >> x;
            if(x != 0){
                dp.push_back(x);
            }
        }
        if(dp.empty()) cout << 0;
        else {
            for(i = 0; i < dp.size(); i++){
                if(i > 0) cout << " ";
                cout << dp[i];
            }
        }
        cout << "\n";
    }
}

int main(){
    solve();
    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////// All in All UVA - 10340
#include<bits/stdc++.h>
using namespace std;

int main(){
    string s,t;
    while(cin >> s >> t){
        int i = 0;
        for(auto j : t){
            i += j == s[i];
        }
        cout << (i == s.size() ? "Yes" : "No") << endl;
    }
}

///////////////////////////////////////////////////////////////////////////////////////// Fill the Square UVA - 11520
#include <iostream>
#include <vector>
using namespace std;

// Usar nombres de variables descriptivos
int numCases;

// Función para verificar si un carácter es válido
bool isValid(vector<string>& grid, int row, int col, char c) {
    if(row > 0 && grid[row-1][col] == c) return false;
    if(row < numCases-1 && grid[row+1][col] == c) return false;
    if(col > 0 && grid[row][col-1] == c) return false;
    if(col < numCases-1 && grid[row][col+1] == c) return false;
    return true;
}

void solve(){
    cin >> numCases;
    vector<string> grid(numCases);
    for(auto &row : grid) cin >> row;

    for(int i = 0; i < numCases; i++) {
        for(int j = 0; j < numCases; j++) {
            if(grid[i][j] == '.') {
                for(char c = 'A'; c <= 'Z'; ++c){
                    if(isValid(grid, i, j, c)) {
                        grid[i][j] = c;
                        break;
                    }
                }
            }
        }
    }

    for(auto &row : grid) cout << row << '\n';
}

int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int t; cin >> t;
    for(int i = 1; i <= t; i++){
        cout << "Case " << i << ":\n";
        solve();
    }

    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////// Short Story Competition UVA - 12482
/////////////////////////////// primera version
#include<bits/stdc++.h>
using namespace std;

int n,l,c;
string s;

int main(){
    while(cin >> n >> l >> c){
        int ll = 0, cc = 0;
        int pages = 1;
        for(int i = 0; i < n; i++){
            cin >> s;
            if(s.length() < c - cc)
                cc += s.length() + 1;
            else if(s.length() == c - cc)
                cc = c;
            else if(s.length() > c - cc){
                cc = s.length();
                if(cc < c)
                    cc++;
                ll++;
                if(ll == l){
                    ll = 0;
                    pages++;
                }
            }
        }
        cout << pages << endl;
    }
}

/////////////////////////////// segunda version
#include<bits/stdc++.h>
using namespace std;

int n, l, c;
string s;

int calculate_pages(int n, int l, int c) {
    int ll = 0, cc = 0;
    int pages = 1;
    for(int i = 0; i < n; i++){
        cin >> s;
        if(s.length() < c - cc)
            cc += s.length() + 1;
        else if(s.length() == c - cc)
            cc = c;
        else if(s.length() > c - cc){
            cc = s.length();
            if(cc < c)
                cc++;
            ll++;
            if(ll == l){
                ll = 0;
                pages++;
            }
        }
    }
    return pages;
}

int main(){
    while(cin >> n >> l >> c){
        cout << calculate_pages(n, l, c) << endl;
    }
}

///////////////////////////////////////////////////////////////////////////////////////// Erasing and Winning UVA - 11491
/////////////////////////////// primera version
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e6 +5;
char ans[maxn];

int main(){
    int n,d;
    while(cin >> n >> d){
        if(n == d and n == 0) break;
        char c;
        map<int, char> m;
        for(int i = 0; i < n; ++i){
            cin >> c;
            if(m.empty()) m[i] = c;
            else{
                while(!m.empty() and d and m.rbegin()->second < c){
                    m.erase(prev(m.end()));
                    d--;
                }
                m[i] = c;
            }
        }
        int cnt = 0;
        while(!m.empty()){
            ans[cnt++] = m.rbegin()->second;
            m.erase(prev(m.end()));
        }
        for(int i = cnt-1; i >= d; --i) cout << ans[i];
        cout << endl;
    }
}

/////////////////////////////// segunda version
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e6 +5;
char ans[maxn];

void process(map<int, char>& m, int& d, char c){
    while(!m.empty() and d and m.rbegin()->second < c){
        m.erase(prev(m.end()));
        d--;
    }
}

void print(map<int, char>& m, int& d){
    int cnt = 0;
    while(!m.empty()){
        ans[cnt++] = m.rbegin()->second;
        m.erase(prev(m.end()));
    }
    for(int i = cnt-1; i >= d; --i) cout << ans[i];
    cout << endl;
}

int main(){
    int n,d;
    while(cin >> n >> d){
        if(n == d and n == 0) break;
        char c;
        map<int, char> m;
        for(int i = 0; i < n; ++i){
            cin >> c;
            if(m.empty()) m[i] = c;
            else{
                process(m, d, c);
                m[i] = c;
            }
        }
        print(m, d);
    }
}

///////////////////////////////////////////////////////////////////////////////////////// Constructing BST UVA - 10821
#include <iostream>

using namespace std;

void dfs(int left, int right, int height) {
    if(left > right)
        return;
    int mid = max(right - (1 << height) + 1, left);
    cout << " " << mid;
    dfs(left, mid - 1, height - 1);
    dfs(mid + 1, right, height - 1);
}

int main() {
    int numCases, maxNodes, caseNum = 0;
    while(cin >> numCases >> maxNodes, numCases || maxNodes){
        cout << "Case " << ++caseNum << ":";
        if(numCases > (1 << maxNodes) - 1)
            cout << " Impossible.";
        else
            dfs(1, numCases, maxNodes - 1);
        cout << "\n";
    }
    return 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <vector>

using namespace std;

int calculateAnswer(int n) {
    int ans = 0;
    string str;
    int previous = (1 << 26) -1;
    for(int i = 0; i < n; i++){
        cin >> str;
        int current = 0;
        for(char c : str){
            current |= (1 << (c - 'a'));
        }
        if(current & previous){
            previous &= current;
        }
        else{
            previous = current;
            ans++;
        }
    }
    return ans;
}

int main() {
    int testCases;
    cin >> testCases;
    while(testCases--) {
        int n;
        cin >> n;
        cout << calculateAnswer(n) << "\n";
    }
    return 0;
}

///////////////////////////////////////////////////////////////////////////////////////// Calculus Simplified UVA - 11890
#include <bits/stdc++.h>
using namespace std;

void readVector(vector<int>& a, int n) {
    for(int i = 0; i < n; i++) cin >> a[i];
}

int calculateCnt(string s, vector<int>& fh, int len) {
    int cnt = 0;
    int top = 0;
    int op = 1;
    for(int i = 0; i < len; i++){
        if(s[i] == 'x') {
            if (op * fh[top] == 1) cnt++;
        }
        else {
            if (s[i] == '(') {
                fh[top + 1] = fh[top] * op;
                ++top;
                op = 1;
            }
            if (s[i] == '+')
                op = 1;
            if (s[i] == '-')
                op = -1;
            if (s[i] == ')')
                top--;
        }
    }
    return cnt;
}

int calculateAns(vector<int>& a, int n, int cnt) {
    int ans = 0;
    for(int i = 0; i < cnt; i++) ans -= a[i];
    for(int i = cnt; i < n; i++) ans += a[i];
    return ans;
}

int main(){
    int t;
    cin >> t;
    while(t--){
        string s;
        cin >> s;
        int n;
        cin >> n;
        vector<int> a(n);
        readVector(a, n);
        sort(a.begin(), a.end());
        int len = s.length();
        vector<int> fh(len+1);
        fh[0] = 1;
        int cnt = calculateCnt(s, fh, len);
        cnt = n - cnt;
        int ans = calculateAns(a, n, cnt);
        cout << ans << endl;
    }
}

///////////////////////////////////////////////////////////////////////////////////////// The jackpot UVA - 10684
/////////////////////////////// primera version
#include <bits/stdc++.h>
using namespace std;

int main(){
    int N;
    while(cin >> N){
        if ( N == 0) break;
        map<int, int> sumMap;
        int result = 0, sum = 0;

        for(int i = 0; i < N; i++){
            int x;
            cin >> x;
            sum += x;
            if(sum < 0){
                sum = 0;
            }
            sumMap[i] = sum;
            if(result < sum)
                result = sum;
        }
        if(result > 0)
            cout << "The maximum winning streak is " << result << "." << endl;
        else
            cout << "Losing streak." << endl;
    }
}

/////////////////////////////// segunda version
#include <bits/stdc++.h>
using namespace std;

int calculateSum(int x, int& sum) {
    sum += x;
    if(sum < 0){
        sum = 0;
    }
    return sum;
}

int calculateResult(int sum, int& result) {
    if(result < sum)
        result = sum;
    return result;
}

void printResult(int result) {
    if(result > 0)
        cout << "The maximum winning streak is " << result << "." << endl;
    else
        cout << "Losing streak." << endl;
}

int main(){
    int N;
    while(cin >> N){
        if ( N == 0) break;
        map<int, int> sumMap;
        int result = 0, sum = 0;

        for(int i = 0; i < N; i++){
            int x;
            cin >> x;
            sumMap[i] = calculateSum(x, sum);
            result = calculateResult(sumMap[i], result);
        }
        printResult(result);
    }
}

///////////////////////////////////////////////////////////////////////////////////////// Maximum Sub-sequence Product UVA - 787
try:
    while True:
        a = input().split("-999999")
        a = a[0].split(" ")
        k = len(a)
        res = int(a[0], 10)
        for i in range(1, k):
            start = 0
            for j in range(0, k-i):
                sum = 1;
                for r in range(j, j+i):
                    sum *= int(a[r], 10)
                if sum > res:
                    res = sum
        print(res)
except EOFError:
    pass

///////////////////////////////////////////////////////////////////////////////////////// Coffee Central UVA - 1105
#include <bits/stdc++.h>
using namespace std;

vector<vector<int>> a;
int x, y, n, q;

void readCoordinates(){
    for(int i = 0; i < n; i++){
        int tx, ty;
        scanf("%d%d", &tx, &ty);
        a[tx+ty][tx-ty+y]++;
    }
}

void updateMatrix(){
    for(int i = 1; i <= x+y; i++){
        for(int j = 1; j <= x+y; j++){
            a[i][j] += a[i-1][j] + a[i][j-1] - a[i-1][j-1];
        }
    }
}

void processQueries(){
    while(q--){
        int m;
        scanf("%d", &m);
        int ans = -1, ansx = 0, ansy = 0;
        for(int i = 1; i <= x; i++){
            for(int j = 1; j <= y; j++){
                int ir = i+j+m, il = i+j-m, jr = i-j+y+m, jl = i-j+y-m;
                if(ir > x+y) ir = x+y;
                if(il < 1) il = 1;
                if(jr > x+y) jr = x+y;
                if(jl < 1) jl = 1;
                int tmp = a[ir][jr] - a[il-1][jr] - a[ir][jl-1] + a[il-1][jl-1];
                if(tmp > ans or tmp == ans and (j < ansy or j == ansy and i < ansx)){
                    ans = tmp;
                    ansx = i;
                    ansy = j;
                }
            }
        }
        printf("%d (%d,%d)\n", ans, ansx, ansy);
    }
}

void solve(){
    a = vector<vector<int>>(x+y+1, vector<int>(x+y+1, 0));
    readCoordinates();
    updateMatrix();
    processQueries();
}

int main(){
    int t = 0;
    while(scanf("%d%d%d%d", &x, &y, &n, &q), x){
        printf("Case %d:\n", ++t);
        solve();
    }
}

///////////////////////////////////////////////////////////////////////////////////////// Garbage Heap UVA - 10755
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const ll INF = 1e18;

ll kadane(vector<vector<vector<ll>>> &v, ll x1, ll x2, ll y1, ll y2, ll h){
    ll maxi = -INF;
    ll local = 0;
    for(ll i = 1; i <= h; i++){
        local = max(local+v[i][x1][y1]+v[i][x2][y2]-v[i][x1][y2]-v[i][x2][y1], v[i][x1][y1]+v[i][x2][y2]-v[i][x1][y2]-v[i][x2][y1]);
        maxi = max(maxi, local);
    }
    return maxi;
}

void readCube(vector<vector<vector<ll>>> &cube, ll a, ll b, ll c, ll &sum){
    for(ll i = 0; i < a; i++){
        for(ll j = 0; j < b; j++){
            for(ll k = 0; k < c; k++){
                cin >> cube[i][j][k];
                sum += cube[i][j][k];
            }
        }
    }
}

void calculateSuffix(vector<vector<vector<ll>>> &suffix, vector<vector<vector<ll>>> &cube, ll a, ll b, ll c){
    for(ll i = 1; i <= a; i++){
        for(ll j = 1; j <= b; j++){
            for(ll k = 1; k <= c; k++){
                suffix[i][j][k] += suffix[i][j][k-1] + cube[i-1][j-1][k-1];
            }
        }
    }

    for(ll i = 1; i <= a; i++){
        for(ll j = 1; j <= b; j++){
            for(ll k = 1; k <= c; k++){
                suffix[i][j][k] += suffix[i][j-1][k];
            }
        }
    }
}

ll findMax(vector<vector<vector<ll>>> &suffix, ll a, ll b, ll c){
    ll ans = -INF;
    for(ll j = 1; j <= b; j++){
        for(ll j2 = 0; j2 < j; j2++){
            for(ll k = 1; k <= c; k++){
                for(ll k2 = 0; k2 < k; k2++){
                    ans = max(ans, kadane(suffix, j, j2, k, k2, a));
                }
            }
        }
    }
    return ans;
}

int main(){
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    ll t;
    cin >> t;

    while(t--) {
        ll a, b, c;
        cin >> a >> b >> c;
        ll sum = 0;

        vector<vector<vector<ll>>> cube(a, vector<vector<ll>>(b, vector<ll>(c, 0)));
        readCube(cube,a,b,c,sum);

        vector<vector<vector<ll>>> suffix(a+1, vector<vector<ll>>(b+1, vector<ll>(c+1, 0)));
        calculateSuffix(suffix,cube,a,b,c);

        cout << findMax(suffix,a,b,c) << "\n";
        if(t) cout << "\n";
    }
}